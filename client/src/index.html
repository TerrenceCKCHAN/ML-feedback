<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>The teapot</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <h1>Hello</h1>
        <script src="js/three.js"></script>
        <!-- <script src="js/libs/loaders/XLoader.js"></script> -->
        
        <script type="x-shader/x-vertex" id="vertexShader" data-src="vertexShader.js">
            varying mat4 mvMatrix; 
            varying mat4 pMatrix;
            varying mat3 nMatrix;
            varying vec3 normalInterpolation;
            varying vec3 vertexPosition;
            
            void main() 
            {
                vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * modelViewPosition;
                mvMatrix = modelViewMatrix;
                pMatrix  = projectionMatrix;
                nMatrix = normalMatrix;
                normalInterpolation = normalMatrix * normal;
                vertexPosition = vec3(modelViewPosition) / modelViewPosition.w;
            }
        </script>

        <script type="x-shader/x-fragment" id="fragmentShader">
            varying mat4 mvMatrix;
            varying mat4 pMatrix;
            varying mat3 nMatrix;
            varying vec3 normalInterpolation;
            varying vec3 vertexPosition;
            float ka  = 0.3;
            float kd  = 0.6;
            float ks  = 0.9;
            float shininess = 30.0;
            vec3 ambientColour = vec3(1,0,0);
            vec3 diffuseColour = vec3(1,0,0);
            vec3 specularColour = vec3(1,1,1);

            void main() {
                vec4 lightPosition = vec4(5,3,6,0);
                vec4 lPos_camSpace = pMatrix * mvMatrix * lightPosition;
                vec4 fragPos_camSpace = pMatrix * mvMatrix * gl_FragCoord;

                // Diffuse Component
                vec3 l = normalize(vec3(lightPosition) - vec3(vertexPosition));
                vec3 n = normalize(normalInterpolation);
                float nDotL = max(0.0, dot(n,l));

                // Specular Component
                vec3 r = reflect(-l, n);
                vec3 v = normalize(-vertexPosition);
                float rDotV = max(0.0, dot(r, v));
                
                
                gl_FragColor = 
                vec4(
                ka * ambientColour + 
                kd * nDotL * diffuseColour +
                ks * pow(rDotV, shininess) * specularColour
                , 1.0);
            }
        </script>
        
        
        <script id="canvas">	

            var scene = new THREE.Scene();

            loadAll()
            function loadAll() {
                var fileLoader = new THREE.FileLoader(fileManager);
                var fileManager = new THREE.LoadingManager(loadModels);
                var vShader;
                var sShader;
                fileLoader.load("./shaders/vertexShader.txt", function(data) {loadModels(data);});
            }

            function loadModels(vShader) {
                var manager = new THREE.LoadingManager(animate);
                var loader = new THREE.ObjectLoader(manager);
                
                loader.load('teapot-claraio.json', function(obj) {
                    applyMaterials(obj, vShader);
                    scene.add(obj);
                })
            }


            

            function addShaderMaterials(vShader) {
                return new THREE.ShaderMaterial({
                    // wireframe: true,
                    vertexShader: vShader,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                });
            }

            function applyMaterials(obj, vShader) {
                obj.traverse(function(child) {
                if (child instanceof THREE.Mesh){
                    child.material = addShaderMaterials(vShader);
                }
                obj.needsUpdate=true;
                });
            }
            
            //LIGHTS
            var light = new THREE.AmbientLight(0xfffff, 0.5);
            // scene.add(light);
            
            var pointLight = new THREE.PointLight(0xfffff,0.5);
            // scene.add(pointLight);

            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            var renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.domElement.id = 'the_canvas';
            document.body.appendChild( renderer.domElement );
            
            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshBasicMaterial( { color: 0xf0ff00 } );
            var cube = new THREE.Mesh( geometry, material );
            // scene.add( cube );
            
            camera.position.y = 1;
            camera.position.z = 3;
            

            // API to postImage to server
            function postImage(image) {
                fetch('http://localhost:3001/post' , {
                    mode: "no-cors",
                    method: 'post',
                    headers: {
                        // "Content-Type": "application/json"
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    body: JSON.stringify({image})
                    // body: JSON.stringify({
                    //     description: 'Posting image',
                    //     public: true,
                    //     files: {
                    //         'img.png': {
                    //             content: null
                    //         }
                    //     }
                    // })
                })
                .catch(err => console.error('Caught Error: ' + err))
            }
            function generateTrainingData() {
                var imageData = renderer.domElement.toDataURL("image/png").replace("image/png", "image/octet-stream");
                console.log(imageData);
                postImage(imageData);
            }
            
            // Scene rendering starts upon completion of loading
            var i = 0;
            function animate() {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
    	        requestAnimationFrame( animate );
                renderer.render( scene, camera );
                
                while (i < 100) {
                    generateTrainingData();
                    sleep(5);
                    // window.location.href = imageData;
                    ++i;
                }
                
            }

            const sleep = (ms) => {
                return new Promise(resolve => setTimeout(resolve, ms))
            }
            


        </script>
        
	</body>
</html>
